//! {{plugin_name}} - A Bubbaloop plugin
//!
//! {{description}}
//!
//! This plugin uses the BubbleNode trait for standardized lifecycle management.

use bubbaloop::prelude::*;
use serde::Serialize;
use std::time::Duration;

/// Plugin configuration - loaded from config.yaml
#[derive(Debug, Deserialize)]
pub struct Config {
    /// Topic to publish data to
    #[serde(default = "default_topic")]
    pub topic: String,

    /// Interval between publishes in seconds
    #[serde(default = "default_interval")]
    pub interval_secs: u64,
}

fn default_topic() -> String {
    "{{plugin_name}}/data".to_string()
}

fn default_interval() -> u64 {
    60
}

/// Data message published by this plugin
#[derive(Debug, Serialize)]
struct PluginData {
    value: f64,
    timestamp: u64,
    message: String,
}

/// The main plugin node
pub struct {{plugin_name_pascal}}Node {
    ctx: Arc<ZContext>,
    config: Config,
}

#[async_trait]
impl BubbleNode for {{plugin_name_pascal}}Node {
    type Config = Config;

    fn metadata() -> BubbleMetadata {
        BubbleMetadata {
            name: "{{plugin_name}}",
            version: "0.1.0",
            description: "{{description}}",
            topics_published: &["{{plugin_name}}/data"],
            topics_subscribed: &[],
        }
    }

    fn new(ctx: Arc<ZContext>, config: Self::Config) -> Result<Self, NodeError> {
        info!("Initializing {{plugin_name}} node");
        info!("  Topic: {}", config.topic);
        info!("  Interval: {}s", config.interval_secs);

        Ok(Self { ctx, config })
    }

    async fn run(self, mut shutdown: watch::Receiver<()>) -> Result<(), NodeError> {
        // Create publisher using ROS-Z context
        // For JSON data, use raw Zenoh session
        let session = self.ctx.session();
        let publisher = session
            .declare_publisher(&self.config.topic)
            .await
            .map_err(|e| NodeError::Zenoh(e.to_string()))?;

        info!("Publishing to: {}", self.config.topic);

        let mut counter = 0u64;
        let interval = Duration::from_secs(self.config.interval_secs);

        loop {
            tokio::select! {
                // Check for shutdown signal
                _ = shutdown.changed() => {
                    info!("Shutdown signal received");
                    break;
                }

                // Publish data at interval
                _ = tokio::time::sleep(interval) => {
                    // Generate data (replace with your plugin logic)
                    let data = PluginData {
                        value: 42.0 + (counter as f64 * 0.1),
                        timestamp: std::time::SystemTime::now()
                            .duration_since(std::time::UNIX_EPOCH)
                            .unwrap()
                            .as_secs(),
                        message: format!("Hello from {{plugin_name}}! Count: {}", counter),
                    };

                    // Serialize and publish
                    let json = serde_json::to_string(&data)
                        .map_err(|e| NodeError::Runtime(e.to_string()))?;

                    publisher
                        .put(json.as_bytes())
                        .await
                        .map_err(|e| NodeError::Zenoh(e.to_string()))?;

                    debug!("Published: {:?}", data);
                    counter += 1;
                }
            }
        }

        info!("{{plugin_name}} node stopped");
        Ok(())
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // run_node handles:
    // - CLI argument parsing (--config, --endpoint)
    // - Logging setup
    // - Config loading from YAML
    // - Zenoh connection
    // - Ctrl+C handling
    // - Graceful shutdown
    run_node::<{{plugin_name_pascal}}Node>().await
}
