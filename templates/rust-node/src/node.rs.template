//! {{node_name}} node implementation

use anyhow::{anyhow, Context, Result};
use serde::{Deserialize, Serialize};
use std::path::Path;
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use zenoh::bytes::ZBytes;
use zenoh::handlers::FifoChannelHandler;
use zenoh::pubsub::{Publisher, Subscriber};
use zenoh::sample::Sample;

/// Protobuf FileDescriptorSet bytes generated by prost-build (if protos/ exists)
/// Contains schema definitions for all protobuf messages in this node.
/// Served via a Zenoh queryable so the dashboard can decode messages dynamically.
#[cfg(feature = "proto")]
pub const DESCRIPTOR: &[u8] = include_bytes!(concat!(env!("OUT_DIR"), "/descriptor.bin"));

/// Node configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Config {
    /// Topic to publish to
    pub publish_topic: String,

    /// Topic to subscribe to (optional)
    pub subscribe_topic: Option<String>,

    /// Publishing rate in Hz
    pub rate_hz: f64,
}

impl Default for Config {
    fn default() -> Self {
        Self {
            publish_topic: "{{node_name}}/output".to_string(),
            subscribe_topic: None,
            rate_hz: 1.0,
        }
    }
}

/// {{node_name_pascal}} node
pub struct {{node_name_pascal}}Node {
    config: Config,
    session: zenoh::Session,
}

impl {{node_name_pascal}}Node {
    /// Create a new node instance
    pub async fn new(config_path: &Path, endpoint: Option<String>) -> Result<Self> {
        // Load configuration
        let config = if config_path.exists() {
            let content = std::fs::read_to_string(config_path)
                .context("Failed to read config file")?;
            serde_yaml::from_str(&content)
                .context("Failed to parse config file")?
        } else {
            log::warn!("Config file not found, using defaults");
            Config::default()
        };

        // Create zenoh session
        let mut zenoh_config = zenoh::Config::default();
        if let Some(ep) = endpoint {
            zenoh_config
                .insert_json5("connect/endpoints", &format!(r#"["{}"]"#, ep))
                .unwrap();
        }

        let session = zenoh::open(zenoh_config)
            .await
            .map_err(|e| anyhow!("Failed to open zenoh session: {}", e))?;

        log::info!("Connected to zenoh");
        log::info!("Publishing to: {}", config.publish_topic);
        if let Some(ref topic) = config.subscribe_topic {
            log::info!("Subscribing to: {}", topic);
        }

        Ok(Self { config, session })
    }

    /// Run the node main loop
    pub async fn run(&mut self, running: Arc<AtomicBool>) -> Result<()> {
        let publisher: Publisher<'_> = self.session
            .declare_publisher(&self.config.publish_topic)
            .await
            .map_err(|e| anyhow!("Failed to create publisher: {}", e))?;

        // Declare schema queryable so the dashboard can fetch our protobuf schemas
        #[cfg(feature = "proto")]
        let _schema_queryable = self.session
            .declare_queryable("{{node_name}}/schema")
            .complete(true)
            .callback(|query| {
                log::debug!("Schema query received");
                let _ = query.reply(query.key_expr(), ZBytes::from(DESCRIPTOR.to_vec()));
            })
            .await
            .map_err(|e| anyhow!("Failed to create schema queryable: {}", e))?;

        // Optional subscriber
        let subscriber: Option<Subscriber<FifoChannelHandler<Sample>>> = if let Some(ref topic) = self.config.subscribe_topic {
            Some(
                self.session
                    .declare_subscriber(topic)
                    .await
                    .map_err(|e| anyhow!("Failed to create subscriber: {}", e))?
            )
        } else {
            None
        };

        let interval = std::time::Duration::from_secs_f64(1.0 / self.config.rate_hz);
        let mut sequence: u64 = 0;

        while running.load(Ordering::SeqCst) {
            // Check for incoming messages
            if let Some(ref sub) = subscriber {
                while let Ok(Some(sample)) = sub.try_recv() {
                    self.handle_message(&sample).await?;
                }
            }

            // Publish output
            let output = self.process(sequence).await?;
            publisher
                .put(output)
                .await
                .map_err(|e| anyhow!("Failed to publish: {}", e))?;

            sequence += 1;
            tokio::time::sleep(interval).await;
        }

        Ok(())
    }

    /// Handle incoming message
    async fn handle_message(&self, sample: &Sample) -> Result<()> {
        let payload = sample.payload().to_bytes();
        log::debug!(
            "Received {} bytes from {}",
            payload.len(),
            sample.key_expr()
        );
        // TODO: Process incoming message
        Ok(())
    }

    /// Process and generate output
    async fn process(&self, sequence: u64) -> Result<Vec<u8>> {
        // TODO: Implement your processing logic here
        let output = serde_json::json!({
            "sequence": sequence,
            "timestamp": chrono::Utc::now().to_rfc3339(),
            "data": "Hello from {{node_name}}"
        });

        Ok(serde_json::to_vec(&output)?)
    }
}
