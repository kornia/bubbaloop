//! {{node_name}} node implementation

use anyhow::{anyhow, Context, Result};
use serde::{Deserialize, Serialize};
use std::path::Path;
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use zenoh::bytes::ZBytes;
use zenoh::handlers::FifoChannelHandler;
use zenoh::pubsub::{Publisher, Subscriber};
use zenoh::sample::Sample;

/// Protobuf FileDescriptorSet bytes generated by prost-build (if protos/ exists)
/// Contains schema definitions for all protobuf messages in this node.
/// Served via a Zenoh queryable so the dashboard can decode messages dynamically.
#[cfg(feature = "proto")]
pub const DESCRIPTOR: &[u8] = include_bytes!(concat!(env!("OUT_DIR"), "/descriptor.bin"));

/// Get machine ID from environment or hostname
fn get_machine_id() -> String {
    std::env::var("BUBBALOOP_MACHINE_ID").unwrap_or_else(|_| {
        hostname::get()
            .ok()
            .and_then(|h| h.into_string().ok())
            .unwrap_or_else(|| "unknown".to_string())
            .replace('-', "_")
    })
}

/// Get scope from environment, defaults to "local"
fn get_scope() -> String {
    std::env::var("BUBBALOOP_SCOPE").unwrap_or_else(|_| "local".to_string())
}

fn default_data_classification() -> String {
    "internal".to_string()
}

fn default_clock_source() -> String {
    "system_realtime".to_string()
}

fn default_timestamp_field() -> String {
    "timestamp".to_string()
}

fn default_timestamp_unit() -> String {
    "milliseconds".to_string()
}

/// Node configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Config {
    /// Topic suffix to publish to (appended to bubbaloop/{scope}/{machine_id}/{{node_name}}/)
    pub publish_topic: String,

    /// Topic to subscribe to (optional)
    pub subscribe_topic: Option<String>,

    /// Publishing rate in Hz
    pub rate_hz: f64,

    /// Node capabilities (e.g., "sensor", "actuator")
    #[serde(default)]
    pub capabilities: Vec<String>,

    /// Hardware requirements (e.g., "camera", "network")
    #[serde(default)]
    pub requires_hardware: Vec<String>,

    /// Data classification (internal, confidential, public)
    #[serde(default = "default_data_classification")]
    pub data_classification: String,

    /// Clock source for timestamps
    #[serde(default = "default_clock_source")]
    pub clock_source: String,

    /// Timestamp field name in messages
    #[serde(default = "default_timestamp_field")]
    pub timestamp_field: String,

    /// Timestamp unit
    #[serde(default = "default_timestamp_unit")]
    pub timestamp_unit: String,
}

impl Default for Config {
    fn default() -> Self {
        Self {
            publish_topic: "output".to_string(),
            subscribe_topic: None,
            rate_hz: 1.0,
            capabilities: Vec::new(),
            requires_hardware: Vec::new(),
            data_classification: default_data_classification(),
            clock_source: default_clock_source(),
            timestamp_field: default_timestamp_field(),
            timestamp_unit: default_timestamp_unit(),
        }
    }
}

/// {{node_name_pascal}} node
pub struct {{node_name_pascal}}Node {
    config: Config,
    session: zenoh::Session,
}

impl {{node_name_pascal}}Node {
    /// Create a new node instance
    pub async fn new(config_path: &Path, endpoint: Option<String>) -> Result<Self> {
        // Load configuration
        let config = if config_path.exists() {
            let content = std::fs::read_to_string(config_path)
                .context("Failed to read config file")?;
            serde_yaml::from_str(&content)
                .context("Failed to parse config file")?
        } else {
            log::warn!("Config file not found, using defaults");
            Config::default()
        };

        // Create zenoh session
        let mut zenoh_config = zenoh::Config::default();

        // Resolve endpoint: CLI arg > env var > default
        let ep = endpoint
            .or_else(|| std::env::var("BUBBALOOP_ZENOH_ENDPOINT").ok())
            .unwrap_or_else(|| "tcp/127.0.0.1:7447".to_string());
        zenoh_config
            .insert_json5("connect/endpoints", &format!(r#"["{}"]"#, ep))
            .unwrap();

        // Disable scouting to prevent connecting to remote peers via Tailscale/VPN
        zenoh_config.insert_json5("scouting/multicast/enabled", "false").ok();
        zenoh_config.insert_json5("scouting/gossip/enabled", "false").ok();

        let session = zenoh::open(zenoh_config)
            .await
            .map_err(|e| anyhow!("Failed to open zenoh session: {}", e))?;

        log::info!("Connected to zenoh");

        Ok(Self { config, session })
    }

    /// Run the node main loop
    pub async fn run(&mut self, running: Arc<AtomicBool>) -> Result<()> {
        let scope = get_scope();
        let machine_id = get_machine_id();
        let topic_prefix = format!("bubbaloop/{}/{}/{{{{node_name}}}}", scope, machine_id);

        log::info!("Node scoped topic prefix: {}", topic_prefix);

        // Construct full publish topic
        let full_publish_topic = format!("{}/{}", topic_prefix, self.config.publish_topic);
        log::info!("Publishing to: {}", full_publish_topic);

        if let Some(ref topic) = self.config.subscribe_topic {
            log::info!("Subscribing to: {}", topic);
        }

        let publisher: Publisher<'_> = self.session
            .declare_publisher(&full_publish_topic)
            .await
            .map_err(|e| anyhow!("Failed to create publisher: {}", e))?;

        // Declare schema queryable so the dashboard can fetch our protobuf schemas.
        // NOTE: Do NOT use .complete(true) â€” it blocks wildcard queries (e.g., "bubbaloop/**/schema")
        // from reaching other queryables. The .wait() call is required to actually send the reply.
        #[cfg(feature = "proto")]
        let schema_key = format!("{}/schema", topic_prefix);
        #[cfg(feature = "proto")]
        let _schema_queryable = self.session
            .declare_queryable(&schema_key)
            .callback(|query| {
                use zenoh::Wait;
                log::debug!("Schema query received");
                if let Err(e) = query.reply(query.key_expr(), ZBytes::from(DESCRIPTOR.to_vec())).wait() {
                    log::warn!("Failed to reply to schema query: {}", e);
                }
            })
            .await
            .map_err(|e| anyhow!("Failed to create schema queryable: {}", e))?;

        // Declare manifest queryable for node metadata
        let manifest_config = self.config.clone();
        let manifest_scope = scope.clone();
        let manifest_machine_id = machine_id.clone();
        let manifest_prefix = topic_prefix.clone();
        let manifest_publish = full_publish_topic.clone();
        let _manifest_queryable = self.session
            .declare_queryable(&format!("{}/manifest", topic_prefix))
            .callback(move |query| {
                use zenoh::Wait;
                log::debug!("Manifest query received");
                let manifest = serde_json::json!({
                    "name": "{{node_name}}",
                    "version": "0.1.0",
                    "language": "rust",
                    "description": "{{description}}",
                    "machine_id": &manifest_machine_id,
                    "scope": &manifest_scope,
                    "capabilities": &manifest_config.capabilities,
                    "requires_hardware": &manifest_config.requires_hardware,
                    "publishes": [{
                        "topic_suffix": &manifest_config.publish_topic,
                        "full_topic": &manifest_publish,
                        "rate_hz": manifest_config.rate_hz,
                    }],
                    "subscribes": manifest_config.subscribe_topic.as_deref().map(|t| vec![t]).unwrap_or_default(),
                    "schema_key": format!("{}/schema", manifest_prefix),
                    "health_key": format!("{}/health", manifest_prefix),
                    "config_key": format!("{}/config", manifest_prefix),
                    "security": {
                        "acl_prefix": format!("bubbaloop/*/{}/{{{{node_name}}}}/**", manifest_machine_id),
                        "data_classification": &manifest_config.data_classification,
                    },
                    "time": {
                        "clock_source": &manifest_config.clock_source,
                        "timestamp_field": &manifest_config.timestamp_field,
                        "timestamp_unit": &manifest_config.timestamp_unit,
                    },
                });
                if let Err(e) = query.reply(query.key_expr(), ZBytes::from(manifest.to_string().into_bytes())).wait() {
                    log::warn!("Failed to reply to manifest query: {}", e);
                }
            })
            .await
            .map_err(|e| anyhow!("Failed to create manifest queryable: {}", e))?;

        // Declare health queryable for node status monitoring
        let start_time = std::time::Instant::now();
        let _health_queryable = self.session
            .declare_queryable(&format!("{}/health", topic_prefix))
            .callback(move |query| {
                use zenoh::Wait;
                log::debug!("Health query received");
                let health = serde_json::json!({
                    "status": "ok",
                    "uptime_s": start_time.elapsed().as_secs(),
                });
                if let Err(e) = query.reply(query.key_expr(), ZBytes::from(health.to_string().into_bytes())).wait() {
                    log::warn!("Failed to reply to health query: {}", e);
                }
            })
            .await
            .map_err(|e| anyhow!("Failed to create health queryable: {}", e))?;

        // Declare config queryable for read-only configuration access
        let config_json = serde_json::to_string(&self.config).unwrap_or_default();
        let _config_queryable = self.session
            .declare_queryable(&format!("{}/config", topic_prefix))
            .callback(move |query| {
                use zenoh::Wait;
                log::debug!("Config query received");
                if let Err(e) = query.reply(query.key_expr(), ZBytes::from(config_json.as_bytes().to_vec())).wait() {
                    log::warn!("Failed to reply to config query: {}", e);
                }
            })
            .await
            .map_err(|e| anyhow!("Failed to create config queryable: {}", e))?;

        // Declare liveliness token for presence detection
        let _liveliness_token = self.session
            .liveliness()
            .declare_token(&topic_prefix)
            .await
            .map_err(|e| anyhow!("Failed to declare liveliness token: {}", e))?;
        log::info!("Liveliness token declared for {{{{node_name}}}}");

        // Optional subscriber
        let subscriber: Option<Subscriber<FifoChannelHandler<Sample>>> = if let Some(ref topic) = self.config.subscribe_topic {
            Some(
                self.session
                    .declare_subscriber(topic)
                    .await
                    .map_err(|e| anyhow!("Failed to create subscriber: {}", e))?
            )
        } else {
            None
        };

        let interval = std::time::Duration::from_secs_f64(1.0 / self.config.rate_hz);
        let mut sequence: u64 = 0;

        while running.load(Ordering::SeqCst) {
            // Check for incoming messages
            if let Some(ref sub) = subscriber {
                while let Ok(Some(sample)) = sub.try_recv() {
                    self.handle_message(&sample).await?;
                }
            }

            // Publish output
            let output = self.process(sequence).await?;
            publisher
                .put(output)
                .await
                .map_err(|e| anyhow!("Failed to publish: {}", e))?;

            sequence += 1;
            tokio::time::sleep(interval).await;
        }

        Ok(())
    }

    /// Handle incoming message
    async fn handle_message(&self, sample: &Sample) -> Result<()> {
        let payload = sample.payload().to_bytes();
        log::debug!(
            "Received {} bytes from {}",
            payload.len(),
            sample.key_expr()
        );
        // TODO: Process incoming message
        Ok(())
    }

    /// Process and generate output
    async fn process(&self, sequence: u64) -> Result<Vec<u8>> {
        // TODO: Implement your processing logic here
        let output = serde_json::json!({
            "sequence": sequence,
            "timestamp": chrono::Utc::now().to_rfc3339(),
            "data": "Hello from {{node_name}}"
        });

        Ok(serde_json::to_vec(&output)?)
    }
}
