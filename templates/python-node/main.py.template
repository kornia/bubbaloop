#!/usr/bin/env python3
"""{{node_name}} node - {{description}}"""

import argparse
import json
import logging
import os
import re
import signal
import socket
import sys
import time
from datetime import datetime, timezone
from pathlib import Path
from typing import Any

import yaml
import zenoh

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)
logger = logging.getLogger(__name__)

TOPIC_RE = re.compile(r"^[a-zA-Z0-9/_\-\.]+$")


def validate_config(config: dict) -> None:
    """Validate node configuration.

    Args:
        config: Configuration dictionary to validate.

    Raises:
        ValueError: If configuration is invalid.
    """
    rate_hz = config.get("rate_hz", 1.0)
    if not (0.01 <= rate_hz <= 1000.0):
        raise ValueError(f"rate_hz {rate_hz} out of range (0.01-1000.0)")

    topic = config.get("publish_topic", "")
    if not topic or not TOPIC_RE.match(topic):
        raise ValueError(f"publish_topic '{topic}' is invalid")

    # Validate subscribe_topic if present
    subscribe_topic = config.get("subscribe_topic")
    if subscribe_topic and not TOPIC_RE.match(subscribe_topic):
        raise ValueError(f"subscribe_topic '{subscribe_topic}' is invalid")


def _get_machine_id() -> str:
    """Get machine ID from env var or sanitized hostname."""
    machine_id = os.environ.get("BUBBALOOP_MACHINE_ID")
    if machine_id:
        return machine_id.replace("-", "_")
    return socket.gethostname().replace("-", "_")


def _get_scope() -> str:
    """Get scope from env var, default 'local'."""
    return os.environ.get("BUBBALOOP_SCOPE", "local")


def _load_descriptor_set() -> bytes | None:
    """Load the protobuf FileDescriptorSet if available."""
    descriptor_path = Path(__file__).parent / "src" / "descriptor.bin"
    if descriptor_path.exists():
        return descriptor_path.read_bytes()
    return None


class {{node_name_pascal}}Node:
    """{{description}}"""

    def __init__(self, config_path: Path, endpoint: str | None = None):
        # Load configuration
        if config_path.exists():
            with open(config_path) as f:
                self.config = yaml.safe_load(f) or {}
        else:
            logger.warning(f"Config file not found: {config_path}, using defaults")
            self.config = {
                "publish_topic": "output",
                "subscribe_topic": None,
                "rate_hz": 1.0,
                "version": "0.1.0",
                "capabilities": [],
                "requires_hardware": [],
                "commands": [],
                "data_classification": "internal",
                "clock_source": "system_realtime",
                "timestamp_field": "timestamp",
                "timestamp_unit": "milliseconds",
            }

        # Validate configuration
        validate_config(self.config)

        # Resolve scoped topic prefix
        self._machine_id = _get_machine_id()
        self._scope = _get_scope()
        self._node_name = "{{node_name}}"
        self._topic_prefix = f"bubbaloop/{self._scope}/{self._machine_id}/{self._node_name}"
        logger.info(f"Topic prefix: {self._topic_prefix}")

        # Setup zenoh
        zenoh_config = zenoh.Config()

        # Use client mode for proper routing through zenohd router
        zenoh_config.insert_json5('mode', '"client"')

        # Resolve endpoint: CLI arg > env var > default
        if not endpoint:
            endpoint = os.environ.get("BUBBALOOP_ZENOH_ENDPOINT", "tcp/127.0.0.1:7447")
        zenoh_config.insert_json5("connect/endpoints", json.dumps([endpoint]))

        # Disable scouting to prevent connecting to remote peers via Tailscale/VPN
        zenoh_config.insert_json5("scouting/multicast/enabled", "false")
        zenoh_config.insert_json5("scouting/gossip/enabled", "false")

        self.session = zenoh.open(zenoh_config)
        logger.info("Connected to zenoh")

        # Track node start time for health reporting
        self._start_time = time.time()

        # Setup publisher with scoped topic
        publish_suffix = self.config["publish_topic"]
        publish_topic = f"{self._topic_prefix}/{publish_suffix}"
        self.publisher = self.session.declare_publisher(publish_topic)
        logger.info(f"Publishing to: {publish_topic}")

        # Setup health heartbeat publisher
        health_topic = f"bubbaloop/{self._scope}/{self._machine_id}/health/{{{{node_name}}}}"
        self.health_publisher = self.session.declare_publisher(health_topic)
        logger.info(f"Health heartbeat: {health_topic}")

        # Declare schema queryable so the dashboard can fetch our protobuf schemas
        self._descriptor_bytes = _load_descriptor_set()
        self._schema_queryable = None
        if self._descriptor_bytes:
            schema_key = f"{self._topic_prefix}/schema"
            # Do NOT use complete=True â€” it blocks wildcard queries like "bubbaloop/**/schema"
            self._schema_queryable = self.session.declare_queryable(
                schema_key,
                self._on_schema_query,
            )
            logger.info(f"Schema queryable declared on {schema_key}")

        # Declare manifest queryable for node self-description
        manifest_key = f"{self._topic_prefix}/manifest"
        self._manifest_queryable = self.session.declare_queryable(
            manifest_key,
            self._on_manifest_query,
        )
        logger.info(f"Manifest queryable declared on {manifest_key}")

        # Declare health queryable for monitoring
        health_key = f"{self._topic_prefix}/health"
        self._health_queryable = self.session.declare_queryable(
            health_key,
            self._on_health_query,
        )
        logger.info(f"Health queryable declared on {health_key}")

        # Declare config queryable for read-only configuration access
        config_key = f"{self._topic_prefix}/config"
        self._config_queryable = self.session.declare_queryable(
            config_key,
            self._on_config_query,
        )
        logger.info(f"Config queryable declared on {config_key}")

        # Declare command queryable for imperative actions from agents/CLI
        command_key = f"{self._topic_prefix}/command"
        self._command_queryable = self.session.declare_queryable(
            command_key,
            self._on_command_query,
        )
        logger.info(f"Command queryable declared on {command_key}")

        # Declare liveliness token for presence detection
        liveliness_key = f"bubbaloop/{self._scope}/{self._machine_id}/{self._node_name}/liveliness"
        self._liveliness_token = self.session.liveliness().declare_token(liveliness_key)
        logger.info(f"Liveliness token: {liveliness_key}")

        # Setup subscriber (optional)
        self.subscriber = None
        if self.config.get("subscribe_topic"):
            self.subscriber = self.session.declare_subscriber(
                self.config["subscribe_topic"],
                self._on_message,
            )
            logger.info(f"Subscribed to: {self.config['subscribe_topic']}")

        self.running = True
        self.sequence = 0

    def _on_schema_query(self, query: zenoh.Query):
        """Respond to schema queries with our FileDescriptorSet."""
        logger.debug("Schema query received")
        if self._descriptor_bytes:
            query.reply(query.key_expr, self._descriptor_bytes)

    def _build_manifest(self) -> dict[str, Any]:
        """Build the node manifest (self-describing contract)."""
        publish_suffix = self.config.get("publish_topic", "output")
        full_publish_topic = f"{self._topic_prefix}/{publish_suffix}"
        return {
            "name": self._node_name,
            "version": self.config.get("version", "0.1.0"),
            "language": "python",
            "description": "{{description}}",
            "machine_id": self._machine_id,
            "scope": self._scope,
            "capabilities": self.config.get("capabilities", []),
            "requires_hardware": self.config.get("requires_hardware", []),
            "publishes": [
                {
                    "topic_suffix": publish_suffix,
                    "full_topic": full_publish_topic,
                    "rate_hz": self.config.get("rate_hz", 1.0),
                }
            ],
            "subscribes": [self.config["subscribe_topic"]] if self.config.get("subscribe_topic") else [],
            "commands": self.config.get("commands", []),
            "schema_key": f"{self._topic_prefix}/schema",
            "health_key": f"{self._topic_prefix}/health",
            "config_key": f"{self._topic_prefix}/config",
            "command_key": f"{self._topic_prefix}/command",
            "security": {
                "acl_prefix": f"bubbaloop/*/{self._machine_id}/{self._node_name}/**",
                "data_classification": self.config.get("data_classification", "internal"),
            },
            "time": {
                "clock_source": self.config.get("clock_source", "system_realtime"),
                "timestamp_field": self.config.get("timestamp_field", "timestamp"),
                "timestamp_unit": self.config.get("timestamp_unit", "milliseconds"),
            },
        }

    def _on_manifest_query(self, query: zenoh.Query):
        """Respond to manifest queries with node contract JSON."""
        logger.debug("Manifest query received")
        manifest = self._build_manifest()
        query.reply(query.key_expr, json.dumps(manifest).encode())

    def _on_health_query(self, query: zenoh.Query):
        """Respond to health queries."""
        logger.debug("Health query received")
        health = {
            "status": "ok",
            "uptime_s": time.time() - self._start_time,
        }
        query.reply(query.key_expr, json.dumps(health).encode())

    def _on_config_query(self, query: zenoh.Query):
        """Respond to config queries (read-only)."""
        logger.debug("Config query received")
        query.reply(query.key_expr, json.dumps(self.config).encode())

    def _on_command_query(self, query: zenoh.Query):
        """Handle command queries from agents/CLI.

        Request: JSON {"command": "name", "params": {...}}
        Response: JSON {"result": ..., "error": null}
        No payload = list available commands.
        """
        logger.debug("Command query received")
        payload = query.payload
        if payload is None:
            # No payload = list available commands
            commands = self.config.get("commands", [])
            response = {"result": commands, "error": None}
        else:
            try:
                req = json.loads(payload.to_bytes())
                cmd_name = req.get("command", "")
                known_commands = {c["name"] for c in self.config.get("commands", [])}
                if cmd_name in known_commands:
                    result = self.handle_command(cmd_name, req.get("params", {}))
                    response = {"result": result, "error": None}
                else:
                    response = {
                        "result": None,
                        "error": f"Unknown command '{cmd_name}'. Available: {sorted(known_commands)}",
                    }
            except (json.JSONDecodeError, Exception) as e:
                response = {"result": None, "error": str(e)}
        query.reply(query.key_expr, json.dumps(response).encode())

    def handle_command(self, command: str, params: dict[str, Any]) -> Any:
        """Handle a command. Override this method to implement command logic.

        Args:
            command: The command name.
            params: Command parameters.

        Returns:
            The command result (will be JSON-serialized).
        """
        # TODO: Implement your command handling logic here
        return f"Command '{command}' received (not yet implemented)"

    def _on_message(self, sample: zenoh.Sample):
        """Handle incoming messages."""
        payload = sample.payload.to_bytes()
        logger.debug(f"Received {len(payload)} bytes from {sample.key_expr}")
        # TODO: Process incoming message

    def process(self) -> bytes:
        """Process and generate output."""
        # TODO: Implement your processing logic here
        output = {
            "sequence": self.sequence,
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "data": f"Hello from {{node_name}}",
        }
        return json.dumps(output).encode()

    def run(self):
        """Run the node main loop."""
        rate_hz = max(self.config.get("rate_hz", 1.0), 0.01)
        interval = 1.0 / rate_hz
        logger.info(f"{{node_name}} node started (rate: {rate_hz} Hz)")

        # Track last health publish time
        last_health = time.monotonic()

        while self.running:
            # Publish output
            output = self.process()
            self.publisher.put(output)
            self.sequence += 1

            # Health heartbeat (every 5 seconds)
            now = time.monotonic()
            if now - last_health >= 5.0:
                self.health_publisher.put(b"alive")
                last_health = now

            time.sleep(interval)

        logger.info("{{node_name}} node stopped")

    def stop(self):
        """Stop the node."""
        self.running = False

    def close(self):
        """Clean up resources."""
        if self._schema_queryable:
            self._schema_queryable.undeclare()
        if self._manifest_queryable:
            self._manifest_queryable.undeclare()
        if self._health_queryable:
            self._health_queryable.undeclare()
        if self._config_queryable:
            self._config_queryable.undeclare()
        if self._command_queryable:
            self._command_queryable.undeclare()
        # TODO: Undeclare liveliness token when zenoh-python supports it
        # if self._liveliness_token:
        #     self._liveliness_token.undeclare()
        if self.subscriber:
            self.subscriber.undeclare()
        self.publisher.undeclare()
        self.health_publisher.undeclare()
        self.session.close()


def main():
    parser = argparse.ArgumentParser(description="{{description}}")
    parser.add_argument(
        "-c", "--config",
        type=Path,
        default=Path("config.yaml"),
        help="Path to configuration file",
    )
    parser.add_argument(
        "-e", "--endpoint",
        type=str,
        default=None,
        help="Zenoh endpoint to connect to",
    )
    args = parser.parse_args()

    node = None
    try:
        node = {{node_name_pascal}}Node(args.config, args.endpoint)

        # Setup signal handlers
        def signal_handler(signum, frame):
            logger.info("Shutdown signal received")
            node.stop()

        signal.signal(signal.SIGINT, signal_handler)
        signal.signal(signal.SIGTERM, signal_handler)

        node.run()
    finally:
        if node is not None:
            node.close()


if __name__ == "__main__":
    main()


# --- Tests ---
# Run with: python -m pytest main.py

def test_config_defaults():
    """Test that default configuration is valid."""
    config = {
        "publish_topic": "test/output",
        "rate_hz": 1.0,
    }
    validate_config(config)  # Should not raise


def test_config_rate_hz_bounds():
    """Test rate_hz boundary validation."""
    import pytest

    # Too low
    config = {"publish_topic": "test/output", "rate_hz": 0.001}
    with pytest.raises(ValueError, match="rate_hz.*out of range"):
        validate_config(config)

    # Too high
    config = {"publish_topic": "test/output", "rate_hz": 1001.0}
    with pytest.raises(ValueError, match="rate_hz.*out of range"):
        validate_config(config)

    # Valid lower bound
    config = {"publish_topic": "test/output", "rate_hz": 0.01}
    validate_config(config)  # Should not raise

    # Valid upper bound
    config = {"publish_topic": "test/output", "rate_hz": 1000.0}
    validate_config(config)  # Should not raise


def test_topic_validation():
    """Test topic name validation."""
    import pytest

    # Invalid characters
    config = {"publish_topic": "invalid topic!@#", "rate_hz": 1.0}
    with pytest.raises(ValueError, match="publish_topic.*is invalid"):
        validate_config(config)

    # Empty topic
    config = {"publish_topic": "", "rate_hz": 1.0}
    with pytest.raises(ValueError, match="publish_topic.*is invalid"):
        validate_config(config)

    # Valid topic
    config = {"publish_topic": "valid/topic-name_123.test", "rate_hz": 1.0}
    validate_config(config)  # Should not raise


def test_subscribe_topic_validation():
    """Test subscribe_topic validation."""
    import pytest

    # Invalid subscribe_topic
    config = {
        "publish_topic": "test/output",
        "subscribe_topic": "invalid!@#",
        "rate_hz": 1.0,
    }
    with pytest.raises(ValueError, match="subscribe_topic.*is invalid"):
        validate_config(config)

    # Valid subscribe_topic
    config = {
        "publish_topic": "test/output",
        "subscribe_topic": "valid/input-topic",
        "rate_hz": 1.0,
    }
    validate_config(config)  # Should not raise

    # None subscribe_topic (optional)
    config = {
        "publish_topic": "test/output",
        "subscribe_topic": None,
        "rate_hz": 1.0,
    }
    validate_config(config)  # Should not raise
