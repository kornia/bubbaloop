//! Protobuf schemas for bubbaloop nodes
//!
//! Single source of truth for all protobuf definitions shared across
//! bubbaloop nodes. Rust nodes depend on this crate directly;
//! Python nodes compile from the proto sources in `protos/`.
//!
//! # Features
//!
//! - `ros-z`: Enables `MessageTypeInfo`/`WithTypeInfo` impls for ZPub/ZSub
//! - `descriptor`: Enables `get_descriptor_for_message` for MCAP schema registration
//! - `config`: Enables `TopicsConfig` for YAML-based topic configuration

macro_rules! proto_module {
    ($mod_name:ident, $file:literal) => {
        pub mod $mod_name {
            pub mod v1 {
                include!(concat!(env!("OUT_DIR"), "/", $file));
            }
        }
    };
}

proto_module!(header, "bubbaloop.header.v1.rs");
proto_module!(daemon, "bubbaloop.daemon.v1.rs");
proto_module!(machine, "bubbaloop.machine.v1.rs");

// Re-export commonly used types
pub use daemon::v1::{
    CommandResult, CommandType, HealthStatus, NodeCommand, NodeEvent, NodeList,
    NodeState as DaemonNodeState, NodeStatus,
};
pub use header::v1::Header;
pub use machine::v1::{MachineHeartbeat, MachineInfo, MachineList};

// TopicsConfig (behind "config" feature)
#[cfg(feature = "config")]
pub mod config;

// Descriptor utilities (behind "descriptor" feature)
#[cfg(feature = "descriptor")]
mod descriptor_utils {
    use prost::Message;
    use prost_reflect::{DescriptorPool, FileDescriptor};
    use std::sync::OnceLock;

    /// Protobuf FileDescriptorSet bytes generated by prost-build
    pub const DESCRIPTOR: &[u8] = include_bytes!(concat!(env!("OUT_DIR"), "/descriptor.bin"));

    /// Descriptor information for a protobuf message type
    #[derive(Debug, Clone)]
    pub struct MessageDescriptor {
        /// The protobuf FileDescriptorSet bytes containing only the message type and its dependencies.
        pub descriptor_bytes: Vec<u8>,
        /// The fully qualified protobuf type name (e.g., "bubbaloop.camera.v1.CompressedImage")
        pub schema_name: String,
    }

    impl MessageDescriptor {
        /// Create a new MessageDescriptor
        pub fn new(descriptor_bytes: Vec<u8>, schema_name: &str) -> Self {
            Self {
                descriptor_bytes,
                schema_name: schema_name.to_string(),
            }
        }
    }

    /// Parse the full DescriptorPool once and cache it
    static DESCRIPTOR_POOL: OnceLock<DescriptorPool> = OnceLock::new();

    fn get_descriptor_pool() -> &'static DescriptorPool {
        DESCRIPTOR_POOL.get_or_init(|| {
            DescriptorPool::decode(DESCRIPTOR)
                .expect("Failed to decode FileDescriptorSet into DescriptorPool")
        })
    }

    /// Extract a minimal FileDescriptorSet containing only the message type and its dependencies
    fn extract_message_descriptor(type_name: &str) -> Result<Vec<u8>, prost::DecodeError> {
        let pool = get_descriptor_pool();

        let message_descriptor = pool.get_message_by_name(type_name).ok_or_else(|| {
            prost::DecodeError::new(format!(
                "Message type '{}' not found in descriptor pool",
                type_name
            ))
        })?;

        let file_descriptor = message_descriptor.parent_file();

        let mut collected_files = std::collections::HashSet::new();
        let mut files_to_include = Vec::new();

        fn collect_file_and_deps(
            file: &FileDescriptor,
            collected: &mut std::collections::HashSet<String>,
            result: &mut Vec<prost_types::FileDescriptorProto>,
        ) {
            let file_name = file.name();
            if collected.contains(file_name) {
                return;
            }
            collected.insert(file_name.to_string());

            result.push(file.file_descriptor_proto().clone());

            for dep_file in file.dependencies() {
                collect_file_and_deps(&dep_file, collected, result);
            }
        }

        collect_file_and_deps(
            &file_descriptor,
            &mut collected_files,
            &mut files_to_include,
        );

        let minimal_set = prost_types::FileDescriptorSet {
            file: files_to_include,
        };

        let mut bytes = Vec::new();
        minimal_set
            .encode(&mut bytes)
            .map_err(|_| prost::DecodeError::new("Failed to encode FileDescriptorSet"))?;

        Ok(bytes)
    }

    /// Get the protobuf descriptor bytes and schema name for a specific message type
    ///
    /// Returns a `MessageDescriptor` containing a minimal FileDescriptorSet and the
    /// fully qualified protobuf type name. Requires the `ros-z` feature for `MessageTypeInfo`.
    #[cfg(feature = "ros-z")]
    pub fn get_descriptor_for_message<T: ros_z::MessageTypeInfo>(
    ) -> Result<MessageDescriptor, prost::DecodeError> {
        let type_name = T::type_name();
        let descriptor_bytes = extract_message_descriptor(type_name)?;
        Ok(MessageDescriptor::new(descriptor_bytes, type_name))
    }
}

#[cfg(feature = "descriptor")]
pub use descriptor_utils::{MessageDescriptor, DESCRIPTOR};

#[cfg(all(feature = "descriptor", feature = "ros-z"))]
pub use descriptor_utils::get_descriptor_for_message;

// ros-z type info implementations (enables ZPub/ZSub with ProtobufSerdes)
#[cfg(feature = "ros-z")]
mod rosz_impls {
    use ros_z::{MessageTypeInfo, TypeHash, WithTypeInfo};

    macro_rules! impl_type_info {
        ($($type:ty => $name:literal),+ $(,)?) => {
            $(
                impl MessageTypeInfo for $type {
                    fn type_name() -> &'static str { $name }
                    fn type_hash() -> TypeHash { TypeHash::zero() }
                }
                impl WithTypeInfo for $type {}
            )+
        };
    }

    impl_type_info! {
        crate::Header => "bubbaloop.header.v1.Header",
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use prost::Message;

    #[test]
    fn test_header_roundtrip() {
        let header = Header {
            acq_time: 1000,
            pub_time: 2000,
            sequence: 42,
            frame_id: "cam0".into(),
            machine_id: "jetson1".into(),
            scope: "default".into(),
        };
        let bytes = header.encode_to_vec();
        let decoded = Header::decode(bytes.as_slice()).unwrap();
        assert_eq!(decoded.sequence, 42);
        assert_eq!(decoded.frame_id, "cam0");
        assert_eq!(decoded.scope, "default");
    }


    #[test]
    fn test_header_default_has_empty_scope() {
        let header = Header::default();
        assert_eq!(header.scope, "");
        assert_eq!(header.sequence, 0);
    }

    #[test]
    fn test_header_serde_json_roundtrip() {
        let header = Header {
            sequence: 99,
            frame_id: "test".into(),
            ..Default::default()
        };
        let json = serde_json::to_string(&header).unwrap();
        let decoded: Header = serde_json::from_str(&json).unwrap();
        assert_eq!(decoded.sequence, 99);
        assert_eq!(decoded.frame_id, "test");
    }

}
