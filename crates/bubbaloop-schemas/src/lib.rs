//! Protobuf schemas for bubbaloop nodes
//!
//! Single source of truth for all protobuf definitions shared across
//! bubbaloop nodes. Rust nodes depend on this crate directly;
//! Python nodes compile from the proto sources in `protos/`.
//!
//! # Features
//!
//! - `ros-z`: Enables `MessageTypeInfo`/`WithTypeInfo` impls for ZPub/ZSub
//! - `descriptor`: Enables `get_descriptor_for_message` for MCAP schema registration
//! - `config`: Enables `TopicsConfig` for YAML-based topic configuration

macro_rules! proto_module {
    ($mod_name:ident, $file:literal) => {
        pub mod $mod_name {
            pub mod v1 {
                include!(concat!(env!("OUT_DIR"), "/", $file));
            }
        }
    };
}

proto_module!(header, "bubbaloop.header.v1.rs");
proto_module!(camera, "bubbaloop.camera.v1.rs");
proto_module!(weather, "bubbaloop.weather.v1.rs");
proto_module!(daemon, "bubbaloop.daemon.v1.rs");
proto_module!(machine, "bubbaloop.machine.v1.rs");
proto_module!(system_telemetry, "bubbaloop.system_telemetry.v1.rs");
proto_module!(network_monitor, "bubbaloop.network_monitor.v1.rs");

// Re-export commonly used types
pub use camera::v1::{CompressedImage, RawImage};
pub use daemon::v1::{
    CommandResult, CommandType, HealthStatus, NodeCommand, NodeEvent, NodeList,
    NodeState as DaemonNodeState, NodeStatus,
};
pub use header::v1::Header;
pub use machine::v1::{MachineHeartbeat, MachineInfo, MachineList};
pub use network_monitor::v1::{
    CheckStatus, CheckType, HealthCheck, NetworkStatus, Summary,
};
pub use system_telemetry::v1::{
    CpuMetrics, DiskMetrics, LoadMetrics, MemoryMetrics, NetworkMetrics, SystemMetrics,
};
pub use weather::v1::{
    CurrentWeather, DailyForecast, DailyForecastEntry, HourlyForecast, HourlyForecastEntry,
    LocationConfig,
};

// TopicsConfig (behind "config" feature)
#[cfg(feature = "config")]
pub mod config;

// Descriptor utilities (behind "descriptor" feature)
#[cfg(feature = "descriptor")]
mod descriptor_utils {
    use prost::Message;
    use prost_reflect::{DescriptorPool, FileDescriptor};
    use std::sync::OnceLock;

    /// Protobuf FileDescriptorSet bytes generated by prost-build
    pub const DESCRIPTOR: &[u8] = include_bytes!(concat!(env!("OUT_DIR"), "/descriptor.bin"));

    /// Descriptor information for a protobuf message type
    #[derive(Debug, Clone)]
    pub struct MessageDescriptor {
        /// The protobuf FileDescriptorSet bytes containing only the message type and its dependencies.
        pub descriptor_bytes: Vec<u8>,
        /// The fully qualified protobuf type name (e.g., "bubbaloop.camera.v1.CompressedImage")
        pub schema_name: String,
    }

    impl MessageDescriptor {
        /// Create a new MessageDescriptor
        pub fn new(descriptor_bytes: Vec<u8>, schema_name: &str) -> Self {
            Self {
                descriptor_bytes,
                schema_name: schema_name.to_string(),
            }
        }
    }

    /// Parse the full DescriptorPool once and cache it
    static DESCRIPTOR_POOL: OnceLock<DescriptorPool> = OnceLock::new();

    fn get_descriptor_pool() -> &'static DescriptorPool {
        DESCRIPTOR_POOL.get_or_init(|| {
            DescriptorPool::decode(DESCRIPTOR)
                .expect("Failed to decode FileDescriptorSet into DescriptorPool")
        })
    }

    /// Extract a minimal FileDescriptorSet containing only the message type and its dependencies
    fn extract_message_descriptor(type_name: &str) -> Result<Vec<u8>, prost::DecodeError> {
        let pool = get_descriptor_pool();

        let message_descriptor = pool.get_message_by_name(type_name).ok_or_else(|| {
            prost::DecodeError::new(format!(
                "Message type '{}' not found in descriptor pool",
                type_name
            ))
        })?;

        let file_descriptor = message_descriptor.parent_file();

        let mut collected_files = std::collections::HashSet::new();
        let mut files_to_include = Vec::new();

        fn collect_file_and_deps(
            file: &FileDescriptor,
            collected: &mut std::collections::HashSet<String>,
            result: &mut Vec<prost_types::FileDescriptorProto>,
        ) {
            let file_name = file.name();
            if collected.contains(file_name) {
                return;
            }
            collected.insert(file_name.to_string());

            result.push(file.file_descriptor_proto().clone());

            for dep_file in file.dependencies() {
                collect_file_and_deps(&dep_file, collected, result);
            }
        }

        collect_file_and_deps(
            &file_descriptor,
            &mut collected_files,
            &mut files_to_include,
        );

        let minimal_set = prost_types::FileDescriptorSet {
            file: files_to_include,
        };

        let mut bytes = Vec::new();
        minimal_set
            .encode(&mut bytes)
            .map_err(|_| prost::DecodeError::new("Failed to encode FileDescriptorSet"))?;

        Ok(bytes)
    }

    /// Get the protobuf descriptor bytes and schema name for a specific message type
    ///
    /// Returns a `MessageDescriptor` containing a minimal FileDescriptorSet and the
    /// fully qualified protobuf type name. Requires the `ros-z` feature for `MessageTypeInfo`.
    #[cfg(feature = "ros-z")]
    pub fn get_descriptor_for_message<T: ros_z::MessageTypeInfo>(
    ) -> Result<MessageDescriptor, prost::DecodeError> {
        let type_name = T::type_name();
        let descriptor_bytes = extract_message_descriptor(type_name)?;
        Ok(MessageDescriptor::new(descriptor_bytes, type_name))
    }
}

#[cfg(feature = "descriptor")]
pub use descriptor_utils::{MessageDescriptor, DESCRIPTOR};

#[cfg(all(feature = "descriptor", feature = "ros-z"))]
pub use descriptor_utils::get_descriptor_for_message;

// ros-z type info implementations (enables ZPub/ZSub with ProtobufSerdes)
#[cfg(feature = "ros-z")]
mod rosz_impls {
    use ros_z::{MessageTypeInfo, TypeHash, WithTypeInfo};

    macro_rules! impl_type_info {
        ($($type:ty => $name:literal),+ $(,)?) => {
            $(
                impl MessageTypeInfo for $type {
                    fn type_name() -> &'static str { $name }
                    fn type_hash() -> TypeHash { TypeHash::zero() }
                }
                impl WithTypeInfo for $type {}
            )+
        };
    }

    impl_type_info! {
        crate::Header => "bubbaloop.header.v1.Header",
        crate::CompressedImage => "bubbaloop.camera.v1.CompressedImage",
        crate::RawImage => "bubbaloop.camera.v1.RawImage",
        crate::CurrentWeather => "bubbaloop.weather.v1.CurrentWeather",
        crate::HourlyForecast => "bubbaloop.weather.v1.HourlyForecast",
        crate::DailyForecast => "bubbaloop.weather.v1.DailyForecast",
        crate::LocationConfig => "bubbaloop.weather.v1.LocationConfig",
        crate::SystemMetrics => "bubbaloop.system_telemetry.v1.SystemMetrics",
        crate::NetworkStatus => "bubbaloop.network_monitor.v1.NetworkStatus",
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use prost::Message;

    #[test]
    fn test_header_roundtrip() {
        let header = Header {
            acq_time: 1000,
            pub_time: 2000,
            sequence: 42,
            frame_id: "cam0".into(),
            machine_id: "jetson1".into(),
            scope: "default".into(),
        };
        let bytes = header.encode_to_vec();
        let decoded = Header::decode(bytes.as_slice()).unwrap();
        assert_eq!(decoded.sequence, 42);
        assert_eq!(decoded.frame_id, "cam0");
        assert_eq!(decoded.scope, "default");
    }

    #[test]
    fn test_compressed_image_roundtrip() {
        let img = CompressedImage {
            header: Some(Header {
                sequence: 1,
                frame_id: "cam0".into(),
                ..Default::default()
            }),
            format: "h264".into(),
            data: vec![0xDE, 0xAD],
        };
        let bytes = img.encode_to_vec();
        let decoded = CompressedImage::decode(bytes.as_slice()).unwrap();
        assert_eq!(decoded.format, "h264");
        assert_eq!(decoded.data, vec![0xDE, 0xAD]);
        assert_eq!(decoded.header.unwrap().sequence, 1);
    }

    #[test]
    fn test_raw_image_roundtrip() {
        let img = RawImage {
            header: Some(Header::default()),
            width: 1920,
            height: 1080,
            encoding: "rgb8".into(),
            step: 5760,
            data: vec![0; 16],
        };
        let bytes = img.encode_to_vec();
        let decoded = RawImage::decode(bytes.as_slice()).unwrap();
        assert_eq!(decoded.width, 1920);
        assert_eq!(decoded.height, 1080);
        assert_eq!(decoded.encoding, "rgb8");
    }

    #[test]
    fn test_current_weather_roundtrip() {
        let weather = CurrentWeather {
            temperature_2m: 22.5,
            relative_humidity_2m: 65.0,
            wind_speed_10m: 10.0,
            ..Default::default()
        };
        let bytes = weather.encode_to_vec();
        let decoded = CurrentWeather::decode(bytes.as_slice()).unwrap();
        assert!((decoded.temperature_2m - 22.5).abs() < f64::EPSILON);
        assert!((decoded.relative_humidity_2m - 65.0).abs() < f64::EPSILON);
    }

    #[test]
    fn test_header_default_has_empty_scope() {
        let header = Header::default();
        assert_eq!(header.scope, "");
        assert_eq!(header.sequence, 0);
    }

    #[test]
    fn test_header_serde_json_roundtrip() {
        let header = Header {
            sequence: 99,
            frame_id: "test".into(),
            ..Default::default()
        };
        let json = serde_json::to_string(&header).unwrap();
        let decoded: Header = serde_json::from_str(&json).unwrap();
        assert_eq!(decoded.sequence, 99);
        assert_eq!(decoded.frame_id, "test");
    }

    #[test]
    fn test_system_metrics_default() {
        let m = SystemMetrics::default();
        assert!(m.cpu.is_none());
        assert!(m.memory.is_none());
    }

    #[test]
    fn test_network_status_default() {
        let s = NetworkStatus::default();
        assert!(s.summary.is_none());
        assert!(s.checks.is_empty());
    }
}
