use prost::Message;
use prost_reflect::{DescriptorPool, FileDescriptor};
use ros_z::{MessageTypeInfo, TypeHash, WithTypeInfo};
use std::sync::OnceLock;

/// Configuration for topics
pub mod config;

/// CLI commands
pub mod cli;

/// Protobuf schemas for bubbaloop
pub mod schemas {
    pub mod camera {
        pub mod v1 {
            include!(concat!(env!("OUT_DIR"), "/bubbaloop.camera.v1.rs"));
        }
    }
    pub mod header {
        pub mod v1 {
            include!(concat!(env!("OUT_DIR"), "/bubbaloop.header.v1.rs"));
        }
    }
    pub mod weather {
        pub mod v1 {
            include!(concat!(env!("OUT_DIR"), "/bubbaloop.weather.v1.rs"));
        }
    }

    // Re-export commonly used types
    pub use camera::v1::{CompressedImage, RawImage};
    pub use header::v1::Header;
    pub use weather::v1::{
        CurrentWeather, DailyForecast, DailyForecastEntry, HourlyForecast, HourlyForecastEntry,
        LocationConfig,
    };
}

// Re-export commonly used types at crate root
pub use schemas::{
    CompressedImage, CurrentWeather, DailyForecast, DailyForecastEntry, Header, HourlyForecast,
    HourlyForecastEntry, LocationConfig, RawImage,
};

/// Protobuf FileDescriptorSet bytes generated by prost-build
/// Contains the complete schema definitions for all protobuf messages
pub const DESCRIPTOR: &[u8] = include_bytes!(concat!(env!("OUT_DIR"), "/descriptor.bin"));

/// Descriptor information for a protobuf message type
#[derive(Debug, Clone)]
pub struct MessageDescriptor {
    /// The protobuf FileDescriptorSet bytes containing only the message type and its dependencies.
    /// This is a minimal descriptor set that includes only the necessary schema definitions.
    pub descriptor_bytes: Vec<u8>,
    /// The fully qualified protobuf type name (e.g., "bubbaloop.camera.v1.CompressedImage")
    pub schema_name: String,
}

impl MessageDescriptor {
    /// Create a new MessageDescriptor
    pub fn new(descriptor_bytes: Vec<u8>, schema_name: &str) -> Self {
        Self {
            descriptor_bytes,
            schema_name: schema_name.to_string(),
        }
    }
}

/// Parse the full DescriptorPool once and cache it
static DESCRIPTOR_POOL: OnceLock<DescriptorPool> = OnceLock::new();

fn get_descriptor_pool() -> &'static DescriptorPool {
    DESCRIPTOR_POOL.get_or_init(|| {
        DescriptorPool::decode(DESCRIPTOR)
            .expect("Failed to decode FileDescriptorSet into DescriptorPool")
    })
}

/// Extract a minimal FileDescriptorSet containing only the message type and its dependencies
fn extract_message_descriptor(type_name: &str) -> Result<Vec<u8>, prost::DecodeError> {
    let pool = get_descriptor_pool();

    // Get the message descriptor by name
    let message_descriptor = pool.get_message_by_name(type_name).ok_or_else(|| {
        prost::DecodeError::new(format!(
            "Message type '{}' not found in descriptor pool",
            type_name
        ))
    })?;

    // Get the file descriptor that contains this message
    let file_descriptor = message_descriptor.parent_file();

    // Collect this file and all its dependencies
    let mut collected_files = std::collections::HashSet::new();
    let mut files_to_include = Vec::new();

    fn collect_file_and_deps(
        file: &FileDescriptor,
        collected: &mut std::collections::HashSet<String>,
        result: &mut Vec<prost_types::FileDescriptorProto>,
    ) {
        let file_name = file.name();
        if collected.contains(file_name) {
            return;
        }
        collected.insert(file_name.to_string());

        // Add this file's proto - FileDescriptor has file_descriptor_proto() method
        result.push(file.file_descriptor_proto().clone());

        // Recursively collect dependencies
        // dependencies() returns an iterator of FileDescriptor directly, so we don't need the pool
        for dep_file in file.dependencies() {
            collect_file_and_deps(&dep_file, collected, result);
        }
    }

    collect_file_and_deps(
        &file_descriptor,
        &mut collected_files,
        &mut files_to_include,
    );

    // Build minimal FileDescriptorSet
    let minimal_set = prost_types::FileDescriptorSet {
        file: files_to_include,
    };

    // Serialize to bytes
    let mut bytes = Vec::new();
    minimal_set
        .encode(&mut bytes)
        .map_err(|_| prost::DecodeError::new("Failed to encode FileDescriptorSet"))?;

    Ok(bytes)
}

/// Get the protobuf descriptor bytes and schema name for a specific message type
///
/// Returns a `MessageDescriptor` containing:
/// - `descriptor_bytes`: A minimal FileDescriptorSet containing only the message type
///   and its dependencies (imported files). This is more efficient than including
///   all compiled protobuf messages.
/// - `schema_name`: The fully qualified protobuf type name for the message type.
///
/// # Performance
///
/// The full FileDescriptorSet is parsed once and cached. The extraction of the
/// minimal descriptor set happens on each call, but the result is small and efficient.
/// For MCAP recording, you should cache the schema registration (e.g., by topic)
/// to avoid repeatedly calling `add_schema`.
///
/// # Errors
///
/// Returns an error if the message type cannot be found in the descriptor set or
/// if the descriptor set cannot be parsed. In practice, this should never happen
/// for valid message types.
///
/// # Example
///
/// ```rust,no_run
/// use bubbaloop::{get_descriptor_for_message, CompressedImage};
///
/// let descriptor = get_descriptor_for_message::<CompressedImage>()?;
/// // Use descriptor.descriptor_bytes and descriptor.schema_name
/// # Ok::<(), Box<dyn std::error::Error>>(())
/// ```
pub fn get_descriptor_for_message<T: MessageTypeInfo>(
) -> Result<MessageDescriptor, prost::DecodeError> {
    let type_name = T::type_name();
    let descriptor_bytes = extract_message_descriptor(type_name)?;
    Ok(MessageDescriptor::new(descriptor_bytes, type_name))
}

impl MessageTypeInfo for schemas::CompressedImage {
    fn type_name() -> &'static str {
        "bubbaloop.camera.v1.CompressedImage"
    }

    fn type_hash() -> TypeHash {
        TypeHash::zero()
    }
}

impl WithTypeInfo for schemas::CompressedImage {}

impl MessageTypeInfo for schemas::RawImage {
    fn type_name() -> &'static str {
        "bubbaloop.camera.v1.RawImage"
    }

    fn type_hash() -> TypeHash {
        TypeHash::zero()
    }
}

impl WithTypeInfo for schemas::RawImage {}

impl MessageTypeInfo for schemas::CurrentWeather {
    fn type_name() -> &'static str {
        "bubbaloop.weather.v1.CurrentWeather"
    }

    fn type_hash() -> TypeHash {
        TypeHash::zero()
    }
}

impl WithTypeInfo for schemas::CurrentWeather {}

impl MessageTypeInfo for schemas::HourlyForecast {
    fn type_name() -> &'static str {
        "bubbaloop.weather.v1.HourlyForecast"
    }

    fn type_hash() -> TypeHash {
        TypeHash::zero()
    }
}

impl WithTypeInfo for schemas::HourlyForecast {}

impl MessageTypeInfo for schemas::DailyForecast {
    fn type_name() -> &'static str {
        "bubbaloop.weather.v1.DailyForecast"
    }

    fn type_hash() -> TypeHash {
        TypeHash::zero()
    }
}

impl WithTypeInfo for schemas::DailyForecast {}

impl MessageTypeInfo for schemas::LocationConfig {
    fn type_name() -> &'static str {
        "bubbaloop.weather.v1.LocationConfig"
    }

    fn type_hash() -> TypeHash {
        TypeHash::zero()
    }
}

impl WithTypeInfo for schemas::LocationConfig {}
